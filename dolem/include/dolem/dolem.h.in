/*
 Copyright (c) 2008-2014 The Dolem project.

 This file is a part of the Dolem project, and is 
 copyrighted by Pat Huang and/or others who actually
 wrote it.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 See also
 <http://www.opensource.org/licenses/mit-license.php>

 Contact the project <staff.effo@gmail.com> or 
 contact Pat Huang <pat.sh.cn@gmail.com>

*/

/**
 * @file dolem/dolem.h
 *
 * In 2009-2010 Effo Core CPK (Cross-platform Kit) was renamed to
 * Dolem. We plan that Dolem can be a standalone project apart of
 * the entire Effo family (Effo Core, Addons, Devel, GPLed, ...).
 * You may see Dolem hosted on one of the following:
 *   Google Code
 *   GitHub
 *   SourceForge
 *
 * @author Pat Huang
 *
 * @version v2r01
 * @par ChangeLog:
 * @verbatim
 *  ver 1-
 *    r01, 2008dec05, Pat
 *    r02, 2014may01, Pat, moving compiler ID and architecture ID
 *      from Effo CPK core/cpk/impl/cer/ids/ here.
 *      Now Effo use Autotools and M4 to identify them.
 *  ver 2-
 *    r01, 2014may09, Pat, Renaming Effo Core CPK to Dolem as a standalone
 *      project; renaming XXXX_CEID_XXXX to XXXX_COMP_XXXX.
 * @endverbatim
 */

#ifndef DLM_DOLEM_H__
#define DLM_DOLEM_H__

/* for "#pragma once" */
@DLM_PRAGMA_ONCE@

/* Shall not include <config.h> in this header,
but all .c and .cpp source file need to include <config.h> generated by Autotools.
See also gnulib rules. */
//#include <config.h>

/* Don't put the following in any namespace. */

#if defined(__KERNEL__)
/* Linux kernel */
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/mm.h>
#include <linux/completion.h>
#include <linux/sched.h>
#include <linux/mutex.h>
/*kmalloc*/
#include <linux/slab.h>
#include <linux/prefetch.h>
#include <linux/fs.h>
/* struct linux_dirent64 */
#include <linux/dirent.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/signal.h>
#include <linux/ioctl.h>
#include <linux/delay.h>
#include <asm/processor.h>
/*getuser putuser*/
#include <asm/uaccess.h>
#include <linux/version.h>

#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,20)
	/*CR0*/
	#include <asm/processor-flags.h>
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
	#include <asm/semaphore.h>
#endif

#include <asm/pgtable.h>
#include <asm/page.h>
#include <asm/system.h>

#else // __KERNEL__

/* Userspace C/++ */

/**
 * Standard C headers, for both C & C++.
 */
/** printf, FILE* */
#include <stdio.h>
#include <time.h>

/* gnulib */
#include <errno.h>

#ifndef DEBUG
// Only debug version do assert, removed assert in release version
#define	NDEBUG
#endif // DEBUG
#include <assert.h>

/* va_list, va_start */
#include <stdarg.h>

//#ifdef HAVE_SYS_TYPES_H
	// POSIX types
	/* gnulib, GNU __WORDSIZE */
	#include <sys/types.h>
//#endif
//#ifdef HAVE_SYS_STAT_H
	/* gnulib, stat() */
	#include <sys/stat.h>
//#endif
//#ifdef DLM_STDC_HEADERS
	/* gnulib malloc/free */
	#include <stdlib.h>
	/* gnulib offsetof, size_t, ptrdiff_t, etc. */
	#include <stddef.h>
//#else
	// one by one
	//#ifdef HAVE_STDLIB_H
		/* gnulib malloc/free */
	//	#include <stdlib.h>
	//#endif
	//#ifdef HAVE_STDDEF_H
		/* gnulib offsetof, size_t, ptrdiff_t, etc. */
	//	#include <stddef.h>
	//#endif
//#endif
#ifdef HAVE_STRING_H
	// memset, strcpy
	#if !defined STDC_HEADERS && defined HAVE_MEMORY_H
		/* no gnulib */
		#include <memory.h>
	#endif
	/* gnulib */
	#include <string.h>
#else
	/* gnulib */
	#include <string.h>
#endif
//#ifdef HAVE_STRINGS_H
	/* gnulib */
	#include <strings.h>
//#endif
//#ifdef HAVE_INTTYPES_H
	/* gnulib C99 types */
	#include <inttypes.h>
//#endif
//#ifdef HAVE_STDINT_H
	// C99 types
	/* gnulib uintptr_t, uint32_t */
	#include <stdint.h>
//#endif
//#ifdef HAVE_UNISTD_H
	/* gnulib sleep */
	#include <unistd.h>
//#endif
//#ifdef HAVE_ARPA_INET_H
	/* gnulib */
	#include <arpa/inet.h>
//#endif
#ifdef HAVE_DLFCN_H
	/* no gnulib */
	#include <dlfcn.h>
#endif
//#ifdef HAVE_FCNTL_H
	/* gnulib */
	#include <fcntl.h>
//#endif
#ifdef HAVE_LIMITS_H
	/* no gnulib */
	#include <limits.h>
#endif
//#ifdef HAVE_NETDB_H
	/* gnulib */
	#include <netdb.h>
//#endif
//#ifdef HAVE_NETINET_IN_H
	/* gnulib */
	#include <netinet/in.h>
//#endif
//#ifdef HAVE_SYS_IOCTL_H
	/* gnulib */
	#include <sys/ioctl.h>
//#endif
#ifdef HAVE_SYS_PARAM_H
	/* no gnulib */
	#include <sys/param.h>
#endif
//#ifdef HAVE_SYS_SOCKET_H
	/* gnulib */
	#include <sys/socket.h>
//#endif
//#ifdef HAVE_SYS_TIME_H
	/**
	 * gnulib
	 * gettimeofday()
	 * In old version of MS VC/++, there's no timeval structure. But
	 * newer version has it, and it is in <time.h>. While GNU C/++,
	 * it is in <sys/time.h>, in <bits/time.h> actually.
	 */
	#include <sys/time.h>
//#endif
//#ifdef HAVE_TERMIOS_H
	/* gnulib */
	#include <termios.h>
//#endif
#ifdef HAVE_UTIME_H
	/* no gnulib */
	#include <utime.h>
#endif

/**
 * For both C & C++.
 */

#if defined(_MSC_VER)
	/* MS VC++ */
	#define NOMINMAX
	#include <winsock2.h>
	#include <windows.h>
#endif // MSC_VER

#if defined(__GNUC__)
	/* 
	 * GNU, C mainly. C++ should be OK too. 
	 * We do C & C++ mixed, so include them.
	 */
	#include <sys/mman.h>
	#include <sys/epoll.h>
	#include <sys/eventfd.h>
	/* Old linux doesn't have this but <linux/signalfd.h>
	#include <sys/signalfd.h>*/
	#include <sys/sysctl.h>
#ifdef __GLIBC__
	#include <sys/io.h>
#else
	#include <asm/io.h>
#endif
	#include <sys/wait.h>
	#include <ctype.h>
	#include <dirent.h>
	#include <libgen.h>
	/* 
	 * #include <pthread.h>
	 * This will affect __USE_GNU definition of sched.h, 
	 *   so skip it.
	 */

	/* 
	 * #include <linux/if.h>
	 * One cannot include both net/if.h and linux/if.h 
	 */
	#include <net/if.h>
	#include <net/if_arp.h>
	#include <signal.h>
	/*
	 * #include <linux/types.h> for RedHat.
	 */
	#include <linux/types.h>
	#include <linux/if_packet.h>
	#include <linux/if_ether.h>
	/** @todo header added, to review */
	#include <linux/ip.h>
	/*
	 * ethertool
	 */
	#include <linux/ethtool.h>
	#include <linux/sockios.h>
	#include <linux/major.h>
	/* end todo. header adding */
#endif // GNUC

#if defined(__cplusplus)
	// std::size_t, etc.
	#include <cstddef>
	// std::new/delete
	#include <new>

	#include <vector>
	#include <list>
	#include <string>
	#include <map>
	#include <set>
	#include <queue>
	#include <stdexcept>
	using namespace std;

	/* C++, for both GNU & MSVC */
	#if defined(__GNUC__)
		/*
		@deprecated hash_map
		//gcc c++ 4.3.0
		#include <ext/hash_map>
		//c++0x #include <unordered_map>
		using namespace __gnu_cxx;

		////////////
		// hash_map hash<string> in linux
		// /////////////////////////////
		namespace __gnu_cxx
		{
		template<> struct hash<string>
		{
			size_t operator()(const string& s) const
			{
				return __stl_hash_string(s.c_str());
			}
		};
		}
		*/
	#elif defined(_MSC_VER)
		/*
		@deprecated hash_map
		#include <hash_map>
		using namespace stdext;
		*/
	#endif
#endif // cplusplus

#endif //defined(__KERNEL__)

/*
FIXME: Making headers included using HAVE_XXXX_H for cross-platform
portibility purpose, etc. But here includes too many headers.
*/

/* Naming:
_COMP_: Compiler depended environment ID, etc, e.g. DLM_COMP_GNU is for GNU gcc/++.
_ARCH_: CPU/Architecture depended environment ID, etc, e.g. DLM_ARCH_X64 is for x86-64/AMD64.
*/

/* If MSVC/++ ? */
#if 0
 defined(_MSC_VER)
        //(_MSC_VER >= 1400)
        //"Microsoft 8.0 or higher";
        //(_MSC_VER >= 1300)
        //"Microsoft 7";
        //(_MSC_VER >= 1200)
        //"Microsoft 6";
        //(_MSC_VER)
        //"Microsoft, but a version lower than 6";
        /** MS VC/++ */
        #define DLM_COMP_MSVC   _MSC_VER
        #define DLM_COMP_STR    "MS VC/++"
#endif
#define DLM_COMP_MSVC	@DLM_COMP_MSVC@

#define DLM_COMP_WIN64 	@DLM_COMP_WIN64@
#define DLM_COMP_WIN32 	@DLM_COMP_WIN32@

/* If is stdc */
#define DLM_IS_STDC	@DLM_IS_STDC@

/* If is C99? */
#define DLM_IS_C99	@DLM_IS_C99@

/* GNU C/++? */
#if 0
 defined(__GNUC__)
/** GNU C/++ */
	#define DLM_COMP_GNU_MAJOR	__GNUC__
	#if defined(__GNUC_MINOR__)
		/** The GNU C/++ version code */
		#define DLM_COMP_GNU_MINOR	__GNUC_MINOR__
		#define DLM_COMP_GNU	((__GNUC__ << 16) + __GNUC_MINOR__)
		#define DLM_COMP_STR	"GNU C/++ with MINOR"
	#else /* no GNUC_MINOR yet */
		#define DLM_COMP_GNU_MINOR	0
		#define DLM_COMP_GNU	1L
		#define DLM_COMP_STR	"GNU C/++"
	#endif
#endif

#define DLM_COMP_GNU	@DLM_COMP_GNU@
#define DLM_COMP_GNU_MINOR	@DLM_COMP_GNU_MINOR@

#if defined(__GNUC__)
#define DLM_COMP_GNU_REQ 	__GNUC_PREREQ
#else
#define DLM_COMP_GNU_REQ(major, minor) 0
#endif

/* If Intel C/++? */
#if 0
 defined(__INTEL_COMPILER) \
		/* Intel Compiler */ \
		|| defined(__ICC) \
		/* Intel too, ICC */ \
		|| defined(__KCC)
		/* Intel again, KAI C++ */
	#define DLM_COMP_INTEL	1L
	#define DLM_COMP_STR	"Intel C/++"
#endif
#define DLM_COMP_INTEL	@DLM_COMP_INTEL@

#if 0
 defined(__MINGW32__)
	/** MinGW */
	#define DLM_COMP_MINGW	1L
	#define DLM_COMP_STR	"MinGW"
#endif
#define DLM_COMP_MINGW	@DLM_COMP_MINGW@

#if 0
 defined(__COMO__)
	/** Comeau C++ */
	#define DLM_COMP_COMO	1L
	#define DLM_COMP_STR	"Comeau C++"
#endif
#define DLM_COMP_COMO	@DLM_COMP_COMO@

#if 0
defined(__DECC) \
		/* Compaq C/C++ */ \
		|| defined(VAXC) \
		/* Compaq too, C/C++ */ \
		|| defined(__VAXC) 
		/* Compaq again, C/C++ */
	#define DLM_COMP_DEC	1L
	#define DLM_COMP_STR	"Compaq/DEC/VAX C/++"
#endif
#define DLM_COMP_DEC	@DLM_COMP_DEC@

#if 0
defined(_CRAYC)
	/** Cray C/C++ */
	#define DLM_COMP_CRAY	1L
	#define DLM_COMP_STR	"Cray C/++"
#endif
#define DLM_COMP_CRAY	@DLM_COMP_CRAY@

#if 0
defined(__CYGWIN__)
	/** Cygwin */
	#define DLM_COMP_CYGWIN	1L
	#define DLM_COMP_STR	"Cygwin"
#endif
#define DLM_COMP_CYGWIN	@DLM_COMP_CYGWIN@

#if 0
defined(__DCC__)
	/** Diab C/C++ */
	#define DLM_COMP_DIAB	1L
	#define DLM_COMP_STR	"DIAB C/++"
#endif
#define DLM_COMP_DIAB	@DLM_COMP_DIAB@

#if 0
defined(__DMC__) \
		/* Digital Mars */ \
		|| defined(__SC__) \
		/* Digital Mars too */ \
		|| defined(__ZTC__) 
		/* Digital Mars again */ 
	#define DLM_COMP_DM	1L
	#define DLM_COMP_STR	"Digital Mars"
#endif
#define DLM_COMP_DM	@DLM_COMP_DM@

#if 0
defined(__EDG__)
	/** EDG C++ Front End */
	#define DLM_COMP_EDG	1L
	#define DLM_COMP_STR	"EDG C++ Front-End"
#endif
#define DLM_COMP_EDG	@DLM_COMP_EDG@

#if 0
defined(__HP_cc) \
		/* HP ANSI C/aC++ */ \
		|| defined(__HP_aCC)
		/* HP ANSI C/aC++ too */
	#define DLM_COMP_HP	1L
	#define DLM_COMP_STR	"HP ANSI C/aC++"
#endif
#define DLM_COMP_HP	@DLM_COMP_HP@

#if 0
defined(__xlC__) \
		/* IBM XL C/C++ */ \
		|| defined(__IBMC__) \
		/* IBM XL C/C++ too */ \
		|| defined(__IBMCPP__) 
		/* IBM XL C/C++ again */
	#define DLM_COMP_IBM	1L
	#define DLM_COMP_STR	"IBM XL C/++"
#endif
#define DLM_COMP_IBM	@DLM_COMP_IBM@

#if 0
defined(LCC)
	/** LCC */
	#define DLM_COMP_LCC	1L
	#define DLM_COMP_STR	"LCC"
#endif
#define DLM_COMP_LCC	@DLM_COMP_LCC@

#if 0
defined(__HIGHC__)
	/** MetaWare High C/C++ */
	#define DLM_COMP_HIGH	1L
	#define DLM_COMP_STR	"MetaWare Hight C/++"
#endif
#define DLM_COMP_HIGH	@DLM_COMP_HIGH@

#if 0
defined(sgi) \
		/* MIPSpro */ \
		|| defined(__sgi)
		/* MIPSpro too */
	#define DLM_COMP_SGI	1L
	#define DLM_COMP_STR	"SGI/MIPSpro"
#endif
#define DLM_COMP_SGI	@DLM_COMP_SGI@

#if 0
defined(__MRC__) \
		/* MPW C++ */ \
		|| defined(MPW_C) \
		/* MPW C++ too */ \
		|| defined(MPW_CPLUS)
		/* MPW C++ again */
	#define DLM_COMP_MPW	1L
	#define DLM_COMP_STR	"MPW C++"
#endif
#define DLM_COMP_MPW	@DLM_COMP_MPW@	

#if 0
defined(__CC_NORCROFT)
	/** Norcroft C */
	#define DLM_COMP_NORCROFT	1L
	#define DLM_COMP_STR	"Norcroft C"
#endif
#define DLM_COMP_NORCROFT	@DLM_COMP_NORCROFT@	

#if 0
defined(__POCC__)
	/** Pelles C */
	#define DLM_COMP_POCC	1L
	#define DLM_COMP_STR	"Pelles C"
#endif
#define DLM_COMP_POCC	@DLM_COMP_POCC@

#if 0
defined(SASC) \
		/* SAS/C */ \
		|| defined(__SASC) \
		/* SAS/C too */ \
		|| defined(__SASC__)
		/* SAS/C again */
	#define DLM_COMP_SAS	1L
	#define DLM_COMP_STR	"SAS/C"
#endif
#define DLM_COMP_SAS	@DLM_COMP_SAS@

#if 0
defined(_SCO_DS)
	/** SCO */
	#define DLM_COMP_SCO	1L
	#define DLM_COMP_STR	"SCO"
#endif
#define DLM_COMP_SCO	@DLM_COMP_SCO@	

#if 0
defined(__SUNPRO_C) \
		/* Sun Workshop C/C++ */ \
		|| defined(__SUNPRO_CC) 
		/* Sun Workshop C/C++ too */
	#define DLM_COMP_SUN	1L
	#define DLM_COMP_STR	"Sun Workshop C/++"
#endif
#define DLM_COMP_SUN	@DLM_COMP_SUN@

#if 0
defined(__TenDRA__)
	/** TenDRA C/C++ */
	#define DLM_COMP_TENDRA	1L
	#define DLM_COMP_STR	"TenDRA C/++"
#endif
#define DLM_COMP_TENDRA		@DLM_COMP_TENDRA@

#if 0
defined(__TINYC__)
	/** Tiny C */
	#define DLM_COMP_TINY	1L
	#define DLM_COMP_STR	"Tiny C"
#endif
#define DLM_COMP_TINY 	@DLM_COMP_TINY@

#if 0
defined(__USLC__)
	/** USL C */
	#define DLM_COMP_USL	1L
	#define DLM_COMP_STR	"USL C"
#endif
#define DLM_COMP_USL	@DLM_COMP_USL@	

#if 0
defined(__WATCOMC__)
	/** Watcom C++ */
	#define DLM_COMP_WATCOM	1L
	#define DLM_COMP_STR	"Watcom C++"
#endif
#define DLM_COMP_WATCOM	@DLM_COMP_WATCOM@

#if 0
defined(__MWERKS__)
	/** MetroWerks CodeWarrior */
	#define DLM_COMP_MWERKS	1L
	#define DLM_COMP_STR	"MetroWerks CodeWarrior"
#endif
#define DLM_COMP_MWERKS	@DLM_COMP_MWERKS@	

#if 0
defined(__TURBOC__) \
		/* Borland Turbo C */ \
		|| defined(__BORLANDC__) 
		/* Borland C++ */
	#define DLM_COMP_BORLAND	1L
	#define DLM_COMP_STR	"Borland/Turbo C/++"
#endif
#define DLM_COMP_BORLAND	@DLM_COMP_BORLAND@

#if !defined(DLM_COMP_STR)
#define DLM_COMP_STR	"C/++ compiler vendor TBD"
#endif

#if 0
	/* GNU C/C++ */
	/** x86 */
	#if defined(__i386__)
		#if __i386__ > 0
			#define DLM_ARCH_X86	__i386__
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#elif defined(i386)
		#if i386 > 0
			#define DLM_ARCH_X86	i386
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* @todo version __i3/4/5/686__ */

	/* Sun Studio */
	#if defined(__i386)
		#if __i386 > 0
			#define DLM_ARCH_X86	__i386
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* MS VC/++ */
	#if defined(_M_IX86)
		#if _M_IX86 > 0
			#define DLM_ARCH_X86	_M_IX86
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* Watcom C/++ */
	#if defined(__X86__)
		#if __X86__ > 0
			#define DLM_ARCH_X86	__X86__
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#elif defined(_M_IX86)
		#if _M_IX86 > 0
			#define DLM_ARCH_X86	_M_IX86
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* Intel C/++ */
	#if defined(_M_IX86)
		#if _M_IX86 > 0
			#define DLM_ARCH_X86	_M_IX86
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* IBM XL C/++ */
	#if defined(__THW_INTEL__)
		#if __THW_INTEL__ > 0
			#define DLM_ARCH_X86	__THW_INTEL__
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif

	/* Digital Mars */
	#if defined(__I86__)
		#if __I86__ > 0
			#define DLM_ARCH_X86	__I86__
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#elif defined(_M_IX86)
		#if _M_IX86 > 0
			#define DLM_ARCH_X86	_M_IX86
		#else
			#define DLM_ARCH_X86	1L
		#endif
		#define DLM_ARCH_STR	"i386 or compatible"
	#endif
#endif
#define DLM_ARCH_X32	@DLM_ARCH_X32@

#if 0
	/* GNU C/C++ or Sun Studio */
	/** x86_64 */
	#if defined(__x86_64__) 
		#if __x86_64__ > 0
			#define DLM_ARCH_X86_64	__x86_64__
		#else
			#define DLM_ARCH_X86_64	1L
		#endif
		#define DLM_ARCH_STR	"x86-64 or compatible"
	#elif defined(__amd64__) 
		#if __amd64__ > 0 
			#define DLM_ARCH_X86_64	__amd64__
		#else
			#define DLM_ARCH_X86_64	1L
		#endif
		#define DLM_ARCH_STR	"x86-64 or compatible"
	#elif defined(__amd64) 
		#if __amd64 > 0
			#define DLM_ARCH_X86_64	__amd64
		#else
			#define DLM_ARCH_X86_64	1L
		#endif
		#define DLM_ARCH_STR	"x86-64 or compatible"
	#elif defined(__x86_64) 
		#if __x86_64 > 0
			#define DLM_ARCH_X86_64	__x86_64
		#else
			#define DLM_ARCH_X86_64	1L
		#endif
		#define DLM_ARCH_STR	"x86-64 or compatible"
	#endif

	/* MS VC/++ */
	#if defined(_M_X64)
		#if _M_X64 > 0
			#define DLM_ARCH_X86_64	_M_X64
		#else
			#define DLM_ARCH_X86_64	1L
		#endif
		#define DLM_ARCH_STR	"x86-64 or compatible"
	#endif
#endif
#define DLM_ARCH_X64	@DLM_ARCH_X64@

#define DLM_ARCH_X86	@DLM_ARCH_X86@

/* system gnu & x86/x86_64 */
#if DLM_COMP_GNU > 0 
	#define DLM_GNU_X32	DLM_ARCH_X32
	#define DLM_GNU_X64	DLM_ARCH_X64
	#define DLM_GNU_X86	DLM_ARCH_X86
#endif

#if !defined(DLM_GNU_X32)
	#define DLM_GNU_X32	0L
#endif
#if !defined(DLM_GNU_X64)
	#define DLM_GNU_X64	0L
#endif
#if !defined(DLM_GNU_X86)
	#define DLM_GNU_X86	0L
#endif

#if 0
	/* GNU C/C++ */
	#if defined(__alpha__)
		#if __alpha__ > 0
			#define DLM_ARCH_ALPHA	__alpha__	
		#else
			#define DLM_ARCH_ALPHA	1L
		#endif
		#define DLM_ARCH_STR	"ALPHA"
	#endif
	/* @todo version __alpha_ev4/5/6__ */

	/* DEC C */
	#if defined(__alpha)
		#if __alpha > 0
			#define DLM_ARCH_ALPHA	__alpha
		#else
			#define DLM_ARCH_ALPHA	1L
		#endif
		#define DLM_ARCH_STR	"ALPHA"
	#endif

	/* MS VC/++ */
	#if defined(_M_ALPHA)
		#if _M_ALPHA > 0
			#define DLM_ARCH_ALPHA	_M_ALPHA
		#else
			#define DLM_ARCH_ALPHA	1L
		#endif
		#define DLM_ARCH_STR	"ALPHA"
	#endif
#endif
#define DLM_ARCH_ALPHA	@DLM_ARCH_ALPHA@	

/*-----------arm------------*/
/*
ARM instruction set version: 1-5.
v1: ARM1, only had a 26-bit address space. obsolete.
v2 and 2a: in v2a, atomic load-and-store instructions: SWP/SWPB.
  Still had 26-bit address space. obsolete.
v3 and 3G: 32-bit address space. backwords-compatibility support
  for 26-bit. The distinction between v3 and 3G is now obsolete.
v4 and 4T: backwords-compatibility support 26-bit.
  halfword (16-bit data) support.
  T variants for Thumb. T to transfer to Thumb state.
  Thumb version 1.
v5: improve the efficiency of ARM/Thumb internetworking in 
  T variants. Thumb version 2.

M variants: Long multiply instructions, include four extra
  instructions which perform 32x32->64 multiplications
  and 32x32+65->64 multiply-accumulates.since ARM3.

E variants: Enhanced DSP instructions, include a number of
  extra instructions which enhance the performance of an ARM
  processor on typical DSP algorithms.

In order to be able to name a variant that omitted the LDRD,
  STRD, MCRR, MRRC and PLD instructions, the letter P will be used.
  e.g., ARMv5TE vs ARMv5TExP, here "xP" means excluding these five
  instructions.

Obsolete ARM names are ARMv1, ARMv2 ARMv2a and ARMv3G.
Common architectures of nowadays are ARMv3, ARMv3M, ARMv4xM,
  ARMv4, ARMv4TxM, ARMv4T, ARMv5xM, ARMv5, ARMv5TxM, ARMv5T and
  ARMv5TExP, and ARMv5TE, and so on.
*/
#if 0
	/* GNU C/C++ or RealView */
	#if defined(__arm__)
		#if __arm__ > 0
			#define DLM_ARCH_ARM	__arm__
		#else
			#define DLM_ARCH_ARM	1L
		#endif
		#define DLM_ARCH_STR	"ARM"
	#endif
	/* GNU C/C++ or RealView, arch in thumb mode */
	#if defined(__thumb__)
		#if __thumb__ > 0
			#define DLM_ARCH_THUMB	__thumb__
		#else
			#define DLM_ARCH_THUMB	1L
		#endif
		#define DLM_ARCH_STR	"ARM/thumb-mode"
	#endif
#endif
#define DLM_ARCH_ARM	@DLM_ARCH_ARM@	

/*-----------hppa------------*/
#if 0
	/* GNU C/C++ */
	/** HP/PA RISC */
	#if defined(__hppa__)
		#if __hppa__ > 0
			#define DLM_ARCH_HPPA	__hppa__
		#else
			#define DLM_ARCH_HPPA	1L
		#endif
		#define DLM_ARCH_STR	"HP/PA RISC"
	#elif defined(__hppa)
		#if __hppa > 0
			#define DLM_ARCH_HPPA	__hppa
		#else
			#define DLM_ARCH_HPPA	1L
		#endif
		#define DLM_ARCH_STR	"HP/PA RISC"
	#endif
	/* @todo version RISC1/2_1/0 */
#endif
#define DLM_ARCH_HPPA	@DLM_ARCH_HPPA@

/*-----------ia64------------*/
#if 0
	/* GNU C/C++ */
	/** IA64 */
	#if defined(__ia64__)
		#if __ia64__ > 0
			#define DLM_ARCH_IA64	__ia64__
		#else
			#define DLM_ARCH_IA64	1L
		#endif
		#define DLM_ARCH_STR	"IA64"
	#elif defined(_IA64)
		#if _IA64 > 0
			#define DLM_ARCH_IA64	_IA64
		#else
			#define DLM_ARCH_IA64	1L
		#endif
		#define DLM_ARCH_STR	"IA64"
	#elif defined(__IA64__)
		#if __IA64__ > 0
			#define DLM_ARCH_IA64	__IA64__
		#else
			#define DLM_ARCH_IA64	1L
		#endif
		#define DLM_ARCH_STR	"IA64"
	#endif

	/* HP C/C++ */
	#if defined(__ia64)
		#if __ia64 > 0
			#define DLM_ARCH_IA64	__ia64
		#else
			#define DLM_ARCH_IA64	1L
		#endif
		#define DLM_ARCH_STR	"IA64"
	#endif

	/* MS VC/++ or Intel C/++ */
	#if defined(_M_IA64)
		#if _M_IA64 > 0
			#define DLM_ARCH_IA64	_M_IA64
		#else
			#define DLM_ARCH_IA64	1L
		#endif
		#define DLM_ARCH_STR	"IA64"
	#endif
#endif
#define DLM_ARCH_IA64	@DLM_ARCH_IA64@	

/*-----------m68k------------*/
#if 0
	/* GNU C/++ */
	/** m68k*/
	#if defined(__m68k__)
		#if __m68k__ > 0
			#define DLM_ARCH_M68K	__m68k__
		#else
			#define DLM_ARCH_M68K	1L
		#endif
		#define DLM_ARCH_STR	"M68000"
	#endif

	/* SAS/C */
	#if defined(M68000)
		#if M68000 > 0
			#define DLM_ARCH_M68K	M68000
		#else
			#define DLM_ARCH_M68K	1L
		#endif
		#define DLM_ARCH_STR	"M68000"
	#endif
#endif
#define DLM_ARCH_M68K @DLM_ARCH_M68K@

/*-----------mips------------*/
#if 0
	/* GNU C/C++ */
	/** MIPS */
	#if defined(__mips__)
		#if __mips__ > 0
			#define DLM_ARCH_MIPS	__mips__
		#else
			#define DLM_ARCH_MIPS	1L
		#endif
		#define DLM_ARCH_STR	"MIPS family"
	#elif defined(mips)
		#if mips > 0
			#define DLM_ARCH_MIPS	mips
		#else
			#define DLM_ARCH_MIPS	1L
		#endif
		#define DLM_ARCH_STR	"MIPS family"
	#endif

	/* MIPSPro */
	#if defined(__mips)
		#if __mips > 0
			#define DLM_ARCH_MIPS	__mips
		#else
			#define DLM_ARCH_MIPS	1L
		#endif
		#define DLM_ARCH_STR	"MIPS family"
	#endif

	/* Metrowerks */
	#if defined(__MIPS__)
		#if __MIPS__ > 0
			#define DLM_ARCH_MIPS	__MIPS__
		#else
			#define DLM_ARCH_MIPS	1L
		#endif
		#define DLM_ARCH_STR	"MIPS family"
	#endif
#endif
#define DLM_ARCH_MIPS	@DLM_ARCH_MIPS@

/*-----------ppc------------*/
#if 0
	/* GNU C/++ */
	/** PowerPC */
	#if defined(__ppc__)
		#if __ppc__ > 0
			#define DLM_ARCH_PPC	__ppc__
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#elif defined(__powerpc)
		#if __powerpc > 0
			#define DLM_ARCH_PPC	__powerpc
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#elif defined(__powerpc__)
		#if __powerpc__ > 0
			#define DLM_ARCH_PPC	__powerpc__
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#elif defined(__POWERPC__)
		#if __POWERPC__ > 0
			#define DLM_ARCH_PPC	__POWERPC__
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#endif

	/* MS VC/++ */
	#if defeined(_M_PPC)
		#if _M_PPC > 0
			#define DLM_ARCH_PPC	_M_PPC
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#endif

	/* IBM XL C/++ */
	#if defined(_ARCH_PPC)
		#if _ARCH_PPC > 0
			#define DLM_ARCH_PPC	_ARCH_PPC
		#else
			#define DLM_ARCH_PPC	1L
		#endif
		#define DLM_ARCH_STR	"PowerPC"
	#endif
#endif
#define DLM_ARCH_PPC	@DLM_ARCH_PPC@

/*-----------rs6k------------*/
#if 0
	/* IBM XL C/++ */
	/** RS/6000 */
	#if defined(__THW_RS6000)
		#if __THW_RS6000 > 0
			#define DLM_ARCH_RS6K	__THW_RS6000
		#else
			#define DLM_ARCH_RS6K	1L
		#endif
		#define DLM_ARCH_STR	"RS/6000 family"
	#elif defined(_IBMR2)
		#if _IBMR2 > 0
			#define DLM_ARCH_RS6K	_IBMR2
		#else
			#define DLM_ARCH_RS6K	1L
		#endif
		#define DLM_ARCH_STR	"RS/6000 family"
	#elif defined(_POWER)
		#if _POWER > 0
			#define DLM_ARCH_RS6K	_POWER
		#else
			#define DLM_ARCH_RS6K	1L
		#endif
		#define DLM_ARCH_STR	"RS/6000 family"
	#elif defined(_ARCH_PWR)
		#if _ARCH_PWR > 0
			#define DLM_ARCH_RS6K	_ARCH_PWR
		#else
			#define DLM_ARCH_RS6K	1L
		#endif
		#define DLM_ARCH_STR	"RS/6000 family"
	#elif defined(_ARCH_PWR2)
		#if _ARCH_PWR2 > 0
			#define DLM_ARCH_RS6K	_ARCH_PWR2
		#else
			#define DLM_ARCH_RS6K	1L
		#endif
		#define DLM_ARCH_STR	"RS/6000 family"
	#endif
#endif
#define DLM_ARCH_RS6K	@DLM_ARCH_RS6K@	

/*-----------sparc------------*/
#if 0
	/* GNU C/++ */
	/** SPARC */
	#if defined(__sparc__)
		#if __sparc__ > 0
			#define DLM_ARCH_SPARC	__sparc__
		#else
			#define DLM_ARCH_SPARC	1L
		#endif
		#define DLM_ARCH_STR	"SPARC"
	#endif

	/* Sun Studio */
	#if defined(__sparc)
		#if __sparc > 0
			#define DLM_ARCH_SPARC	__sparc
		#else
			#define DLM_ARCH_SPARC	1L
		#endif
		#define DLM_ARCH_STR	"SPARC"
	#endif
#endif
#define DLM_ARCH_SPARC	@DLM_ARCH_SPARC@	

/*-----------sh------------*/
#if 0
	/* GNU C/++ */
	/** SuperH */
	#if defined(__sh__)
		#if __sh__ > 0
			#define DLM_ARCH_SH	__sh__
		#else
			#define DLM_ARCH_SH	1L
		#endif
		#define DLM_ARCH_STR	"SuperH"
	#endif
	/* @todo version __sh/SH1/2/3/4/5__ */
#endif
#define DLM_ARCH_SH	@DLM_ARCH_SH@

/*-----------s370------------*/
#if 0
	/* IBM XL C/++ */
	/** Sysetm/370 */
	#if defined(__370__)
		#if __370__ > 0
			#define DLM_ARCH_S370	__370__
		#else
			#define DLM_ARCH_S370	1L
		#endif
		#define DLM_ARCH_STR	"System/370"
	#elif defined(__THW_370__)
		#if __THW_370__ > 0
			#define DLM_ARCH_S370	__THW_370__
		#else
			#define DLM_ARCH_S370	1L
		#endif
		#define DLM_ARCH_STR	"System/370"
	#endif
#endif
#define DLM_ARCH_S370	@DLM_ARCH_S370@	

/*-----------s390------------*/
#if 0
	/* GNU C/++ */
	/** Sysetm/390 */
	#if defined(__s390__)
		#if __s390__ > 0
			#define DLM_ARCH_S390	__s390__
		#else
			#define DLM_ARCH_S390	1L
		#endif
		#define DLM_ARCH_STR	"System/390"
	#elif defined(__s390x__)
		#if __s390x__ > 0
			#define DLM_ARCH_S390	__s390x__
		#else
			#define DLM_ARCH_S390	1L
		#endif
		#define DLM_ARCH_STR	"System/390"
	#endif
#endif
#define DLM_ARCH_S390 @DLM_ARCH_S390@

#if !defined(DLM_ARCH_STR)
#define DLM_ARCH_STR	"Architecture TBD"
#endif

#if 0
/*-----------------More friendly EfsXXX------------------*/

#define DLM_IS_X86		(DLM_ARCH_X86 > 0)
#define DLM_IS_X64		(DLM_ARCH_X64 > 0)

#define DLM_IS_GNU		(DLM_COMP_GNU > 0)
#define DLM_IS_GNU_X86		(DLM_IS_GNU && DLM_IS_X86)
#define DLM_IS_GNU_X64		(DLM_IS_GNU && DLM_IS_X64)

#define DLM_IS_MSVC		(DLM_COMP_MSVC > 0)
#define DLM_IS_MSVC_X86		(DLM_IS_MSVC && DLM_IS_X86)
#define DLM_IS_MSVC_X64		(DLM_IS_MSVC && DLM_IS_X64)

/** Linux Kernel, not kernel of any other OS */
#define DLM_IS_KERNEL		(defined(__KERNEL__))
#define DLM_IS_CXX		(defined(__cplusplus))

#define DLM_IS_64BIT	(DLM_IS_X64 \
			|| (defined(__SIZEOF_POINTER__) && 8 == __SIZEOF_POINTER__) \
			|| defined(__LP64__) || defined(_LP64) \
			/* LP64 in GNU */ \
			|| defined(CONFIG_X86_64) \
			/* CONFIG_X86_64 in the kernel */ \
			|| DLM_ARCH_ALPHA > 0 \
			|| DLM_ARCH_IA64 > 0 \
			|| DLM_COMP_WIN64 > 0 \
			)

#define DLM_IS_32BIT	(DLM_IS_X86 \
			|| (defined(__SIZEOF_POINTER__) && 4 == __SIZEOF_POINTER__) \
			|| DLM_COMP_WIN32 > 0 \
			)
#if defined(__WORDSIZE)
#	define DLM_BITS		__WORDSIZE
#endif

#endif

/*
C99 doesn't require support for "sizeof" in preprocessor conditionals and many compilers don't support it.
For example, the following lines cannot be compiled:
#if 4 == sizeof(char*)
#define BITS	32
#elif 8 == sizeof(char*)
#define BITS	64
#else
#define BITS	32
#endif
*/

/* defined(__LP64__) || defined(_LP64) 
Datatype  LP64   ILP64  LLP64  ILP32  LP32
---------------------------------------------
char        8      8      8      8     8 // Bad, not exactly in some environment like MCU/DSP
short      16     16     16     16    16 // This looks nice
int32_t    32     32     32     32    32 // Perfact, like u/int8_t, u/int16_t, u/int32_t, u/int64_t
int        32     64     32     32    16 // Bad
long       64     64     32     32    32 // Bad
long long  64     64     64     64    64 // May not have long long in some environment
pointer    64     64     64     32    32 // Nice
*/

/* Worst int: 16|32, long: 32, long long: n/a, ptr: 32 */
#define DLM_LP32	@DLM_LP32@
/* Linux, UNIX?
  Worst int: 32, long: 32, long long: n/a, ptr: 32 */
#define DLM_ILP32	@DLM_ILP32@
/* Worst int: 16|32, long: 16|32, long long: 32, ptr: 32 */
//#define DLM_LLP32	@DLM_LLP32@

/* Linux/UNIX:
  Worst int: 16|32, long: 64, long long: n/a, ptr: 64 */
#define DLM_LP64	@DLM_LP64@
/* Worst int: 64, long: 64, long long: n/a, ptr: 64 */
#define DLM_ILP64	@DLM_ILP64@
/* Windows:
  Worst int: 16|32, long: 16|32, long long: 64, ptr: 64 */
#define DLM_LLP64	@DLM_LLP64@

/* PTR bits or machine word bits */
#define DLM_BITS	@DLM_BITS@

/*
Guideline for using ID:
1. Whether is a 32- or 64-bit system:
  DLM_IS_64BIT DLM_IS_32BIT
2. Need bits directly:
  32 == DLM_BITS, 64 == DLM_BITS
3. Whether is a GNU C/++:
  DLM_IS_GNU
4. Whether is a MS VC/++:
  DLM_IS_MSVC
5. Whether is an x86 or compatible:
  DLM_IS_X86
6. Whether is an x86_64 or compatible:
  DLM_IS_X64
7. Whether is either an x86_64 or an x86 (compatible):
  DLM_IS_X86

*/

/*

Type       GCC-32          GCC-64          MSVC-32     MSVC-64
----------------------------------------------------------------
size_t     unsigned int    unsigned long     signed      ?
ssize_t    signed int      signed long       ?           ?
intptr_t   signed int      signed long       ?           ?
uintptr_t  unsigned int    unsigned long     ?           ?
*/

#if defined(__KERNEL__)
/* The Linux kernel */
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
	/* older kernel has no uintptr_t */
	typedef unsigned long int uintptr_t;
#endif

#define INTPTR_DEFINED	0

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
	/* older kernel has no intptr_t; or non of the kernels has it? */
	typedef signed long int intptr_t;
	#undef INTPTR_DEFINED
	#define INTPTR_DEFINED	1
#endif

#if !INTPTR_DEFINED
	/* non of the kernels has it? */
	typedef signed long int intptr_t;
	#undef INTPTR_DEFINED
	#define INTPTR_DEFINED	1
#endif

#ifndef UINTPTR_C
	#define UINTPTR_C(c)	c##UL
#endif
#ifndef INTPTR_C
	#define INTPTR_C(c)	c##L
#endif

#ifndef PRIdPTR
	#define DLM_PRIPTR_PREFIX "l"
	#define PRIdPTR		DLM_PRIPTR_PREFIX"d"
	#define PRIiPTR		DLM_PRIPTR_PREFIX"i"
	#define PRIoPTR		DLM_PRIPTR_PREFIX"o"
	#define PRIuPTR		DLM_PRIPTR_PREFIX"u"
	#define PRIxPTR		DLM_PRIPTR_PREFIX"x"
	#define PRIXPTR		DLM_PRIPTR_PREFIX"X"
#endif

#else // KERNEL?

/* User space */
/* Make sure we'll have u/intptr_t */
#if 0 // use gnulib to ensure
DLM_HAVE_STDINT_H
	#if @DLM_NO_INTPTR_T@ /* 1 for there's no intptr_t; 0 for we have already */
		/* No intptr_t */
		#if DLM_COMP_GNU > 0
			/* Userspace GNU C/++ */
			typedef signed long int		intptr_t;
		#elif DLM_COMP_MSVC > 0
			/* User space, MS VC/++ */
			#if DLM_BITS > 32 // 64-bit
				typedef signed __int64		intptr_t;
			#elif DLM_BITS < 64 // 32-bit
				/* does MS WIN32 have un/singed long? Not sure */
				typedef signed long		intptr_t;
				//typedef signed int 		intptr_t;
			#endif
		#else
			/* 
			 * Other systems, do it yourself.
			 * Here anyway do something.
			 * Suppose has u/intptr_t type already.
			 */
		#endif
	#endif
	#if @DLM_NO_UINTPTR_T@ /* 1 for there's no intptr_t; 0 for we have already */
		/* No uintptr_t */
		#if DLM_COMP_GNU > 0
			/* Userspace GNU C/++ */
			typedef unsigned long int	uintptr_t;
		#elif DLM_COMP_MSVC > 0
			/* User space, MS VC/++ */
			#if DLM_BITS > 32 // 64-bit
				typedef unsigned __int64	uintptr_t;
			#elif DLM_BITS < 64 // 32-bit
				/* does MS WIN32 have un/singed long? Not sure */
				typedef unsigned long		uintptr_t;
				//typedef unsigned  int 	uintptr_t;
			#endif
		#else
			/* 
			 * Other systems, do it yourself.
			 * Here anyway do something.
			 * Suppose has u/intptr_t type already.
			 */
		#endif
	#endif
#endif // ifndef DLM_HAVE_STDINT_H

// fall through once u/intptr_t determined

/* Not Linux kernel space */
#if !(DLM_BITS == 32 || DLM_BITS == 64) 
	/* 
	 * Not 64- or 32-bit, do it yourself.
	 * Here anyway do something.
	 * Suppose has u/intptr_t type already.
	 */
	#ifndef UINTPTR_C
		#define UINTPTR_C(c)	c##UL
	#endif
	#ifndef INTPTR_C
		#define INTPTR_C(c)	c##L
	#endif

	#define DLM_PRIPTR_PREFIX "l"

#elif DLM_COMP_GNU > 0 
	/* User space, GNU C/++ */
	#if DLM_BITS > 32 // 64-bit
		#ifndef UINTPTR_C
			#define UINTPTR_C(c)	c##UL
		#endif
		#ifndef INTPTR_C
			#define INTPTR_C(c)	c##L
		#endif

		#define DLM_PRIPTR_PREFIX "l"

	#elif DLM_BITS < 64 // 32-bit
		/* GNU 32 uinptr_t is unsigned int. */
		#ifndef UINTPTR_C
			#define UINTPTR_C(c)	c##U
		#endif
		#ifndef INTPTR_C
			#define INTPTR_C(c)	c
		#endif

		#define DLM_PRIPTR_PREFIX

	#endif

#elif DLM_COMP_MSVC > 0
	/* User space, MS VC/++ */
	#if DLM_BITS > 32 
		#ifndef UINTPTR_C
			#define UINTPTR_C(c)	c##ui64
		#endif
		#ifndef INTPTR_C
			#define INTPTR_C(c)	c##i64
		#endif

		#define DLM_PRIPTR_PREFIX "ll"

	#elif DLM_BITS < 64 
		#ifndef UINTPTR_C
			#define UINTPTR_C(c)	c##ui32
		#endif
		#ifndef INTPTR_C
			#define INTPTR_C(c)	c##i32
		#endif

		#define DLM_PRIPTR_PREFIX "l"

	#endif
#else
	/* 
	 * Other systems, do it yourself.
	 * Here anyway do something.
	 * Suppose has u/intptr_t type already.
	 */
	#ifndef UINTPTR_C
		#define UINTPTR_C(c)	c##UL
	#endif
	#ifndef INTPTR_C
		#define INTPTR_C(c)	c##L
	#endif

	#define DLM_PRIPTR_PREFIX "l"

#endif

#ifndef PRIdPTR
	#define PRIdPTR		DLM_PRIPTR_PREFIX"d"
	#define PRIiPTR		DLM_PRIPTR_PREFIX"i"
	#define PRIoPTR		DLM_PRIPTR_PREFIX"o"
	#define PRIuPTR		DLM_PRIPTR_PREFIX"u"
	#define PRIxPTR		DLM_PRIPTR_PREFIX"x"
	#define PRIXPTR		DLM_PRIPTR_PREFIX"X"
#endif

#endif // defined(__KERNEL__)

#ifndef HAVE_PTRDIFF_T
	/* Make sure we'll have ptrdiff_t by using intptr_t */
	typedef intptr_t	ptrdiff_t;
#endif

/*
 * A size type which generally covers the entire address space. 
 *
 * @note
 * If I remembered size_t is signed in Windows.
 * Modifier %z for size_t is C99 only, so modifier 
 *   is not portable between current 32-bit and 64-bit 
 *   GNU C/++ systems. I don't know what's about MS VC/++.
 * In old version of GNU there's no std::size_t.
 * 
 * The size_t type is the unsigned integer type of the 
 *   result of the sizeof operator. 
 * Variables of type size_t are guaranteed to be of 
 *   sufficient precision to represent the size of an 
 *   object. 
 * The limit of size_t is specified by the SIZE_MAX macro.
 *
 * The type size_t generally covers the entire address space. 
 * ISO/IEC TR 24731-1-2007 introduces a new type rsize_t, 
 *   defined to be size_t but explicitly used to hold the 
 *   size of a single object. 
 * In code that documents this purpose by using the type 
 *   rsize_t, the size of an object can be checked to verify 
 *   that it is no larger than RSIZE_MAX, the maximum size of 
 *   a normal single object, which provides additional input 
 *   validation for library functions. 
 * See STR07-C. Use TR 24731 for remediation of existing string 
 *   manipulation code for additional discussion of TR 24731-1.
 *
 * Any variable that is used to represent the size of an object, 
 *   including integer values used as sizes, indices, loop 
 *   counters, and lengths, should be declared as rsize_t if 
 *   available, or otherwise as size_t.
 * @todo use rsize_t.
 * @todo use uintmax_t.
 */
#if 0
#if DLM_COMP_MSVC > 0
	typedef unsigned __int64	uint64_t;
	typedef signed __int64		int64_t;
#endif
#endif

#ifdef __cplusplus
// We still use identical "Effo" namespace.
namespace Effo {
#endif

#if 0
/* MWord - Machine Word */

#if defined(__KERNEL__) || DLM_COMP_GNU > 0
	typedef unsigned long 	cpk_umword_t;	
	#define UMWORD_C(c)	c##UL
	#define UMWORD_PRI	"lu"
	typedef signed long 	cpk_mword_t;	
	#define MWORD_C(c)	c##L
	#define MWORD_PRI	"ld"
#elif DLM_COMP_MSVC > 0
	// we already defined uintptr_t for MSVC
	typedef uintptr_t 	cpk_umword_t;	
	#define UMWORD_C	UINTPTR_C
	#define UMWORD_PRI	UINTPTR_PRI
	typedef intptr_t 	cpk_mword_t;	
	#define MWORD_C		INTPTR_C
	#define MWORD_PRI	INTPTR_PRI
#else
	/* 
	 * Not GNU or MSVC, do it yourself.
	 * Here just do something.
	 */
	typedef unsigned long 	cpk_umword_t;	
	#define UMWORD_C(c)	c##UL
	#define UMWORD_PRI	"lu"
	typedef signed long 	cpk_mword_t;	
	#define MWORD_C(c)	c##L
	#define MWORD_PRI	"ld"
#endif

typedef cpk_mword_t		machine_word;
#endif

/* Note this barrier prevent a compiler from reordering instructions, it is not "mfence" like and does not prevent from reordering by CPU. */
#if DLM_COMP_GNU > 0
#define dlm_barrier() 	asm volatile("" : : : "memory")
#elif DLM_COMP_MSVC > 0
// well I don't know whether _ReadWriteBarrier() is compiler barrier only or it is "mfence" like and prevents from reordering by CPU.
#define dlm_barrier() 	_ReadWriteBarrier()
#else
// Implement it yourself
#endif

/** CPU Register postfix */
#define DLM_REG_OP32	"l"
#define DLM_REG_OP64	"q"
#if DLM_BITS > 32
	/* e.g. 64-bit system */
	#define DLM_REG_OPL	"q" // movq
	#define DLM_REG_PRE	"r" // rax
#else
	/* 32-bit system */
	#define DLM_REG_OPL	"l" // movl
	#define DLM_REG_PRE	"e" // eax
#endif

#ifdef __cplusplus
} //namespace Effo {
#endif

#endif 

